# 说明
- 内容主要是本人学习数据库的笔记汇总。
- 计划的学习路线：
- MySQL（InnoDB)的设计原理 -> B+树 -> 动手实践 -> 其他存储系统的实现。
-
# 名词解释
-
  #+BEGIN_QUOTE
  为避免理解偏差，本文默认使用MySQL数据库，如数据库实例，指的是MySQL中的数据库实例。
  #+END_QUOTE
- **数据库**: 物理操作系统或其他形式文件类型的集合。MySQL中，数据库文件可以是frm、MYD、MYI、idb结尾的文件。
- **数据库实例**: MySQL的数据库实例由后台线程和一个共享内存区组成。（和**数据库**所指的物理文件不同，实例是一个程序，MySQL被设计为单进程多线程架构，其在系统上表现为一个进程）
- **缓冲区**: 内存
- **脏页**: 指缓冲区中的页因为DML操作被修改时，和磁盘上的页出现了不一致，将缓冲区的页称为脏页（Dirty Page）
-
# MySQL中有哪些存储引擎
- MySQL区别于其他数据库的一个主要特点就是其插件式的表存储引擎。（不同存储引擎适用于不同的场景），下面简单介绍下主要的存储引擎及其特点：
-
#### InnoDB
- 设计目标主要面向在线事务处理（OLTP）应用。是MySQL中最常用的存储引擎，具备高可用、高性能以及高可扩展性。
-
#### MyISAM
- 不支持事务、表锁设计，支持全文索引，主要面向一些OLAP数据库应用。特点是它的缓冲池只缓存索引文件，而不缓存数据文件。
-
#### NDB
- 特点是数据全部放在内存中，因此主键查找（primary key lookups）的速度极快，并且通过添加节点可以线性地提高数据库性能，是高可用、高性能的集群系统。
-
#### Maria
- 设计目标是用来取代MyISAM。
-
# InnoDB存储引擎
- InnoDB主要有4个版本，新的版本兼容旧版本，这会体现在一些场景下的实现里。
-
## InnoDB的架构
- InnoDB有多个内存块，可以认为这些内存块组成了一个大的内存池，主要负责：
	-
	  1. 维护所有进程/线程需要访问的多个内部数据结构；
	-
	  2. 缓冲区：缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前在这里缓存；
	-
	  3. 重做日志（Redo Log）缓冲
	- ...
- TODO 补一张图 P19 2-1
  :LOGBOOK:
  CLOCK: [2021-09-13 Mon 00:15]--[2021-09-13 Mon 00:15] =>  00:00
  :END:
-
### 后台线程
- 主要由四类线程组成。
	- **master thread**: 核心线程。负责将缓冲区中的数据异步刷新到磁盘，保证数据的一致性；合并插入缓冲，回收Undo页。
	- **IO Thread**: InnoDB中大量使用AIO（Async IO）来处理写IO请求，以此提升性能（比如合并多个IO的操作）。
	- **Purge Thread**: 事务被提交后，其使用的Undo Log可能不再需要，因此需要回收已经使用并分配的undo页。
	- **Page Cleaner Thread**: 1.2.x版本引入，作用是将之前版本中脏页的刷新操作放到单独的线程来减轻main thread的工作，以提升整体性能。
-
### 内存
#### 缓冲池
-
  1. InnoDB是基于磁盘的数据库系统（Disk-base Database)，其将磁盘中的记录按照「**页**」的方式进行管理。
-
  2. 缓冲池就是一块内存区域：
	- 在DB中进行读取页的操作时，首先将从磁盘读到的页存放到缓冲池中，下一次再读相同的页，首先判断该页是否在缓冲池，若在，称该页在缓冲池中被命中，直接读取该页，否则读取磁盘上的页。
	- 在DB中进行修改页的操作时，则首先修改在缓冲池中的页（问题1），然后再以一定频率将缓冲池刷回磁盘。这里的刷会操作是通过「**Checkpoint机制**」实现的。
- TODO 补InnoDB内存结构图
-
  3. InnoDB通过LRU算法管理缓冲池。不同的是，它还引入了**midpoint策略（midpoint insertion strategy）**：即新读取到的页并不直接放到LRU的首部，而是放到LRU列表的midpoint位置（默认5/8处）。在midpoint之前的称为new list（最活跃的页），之后的称为old list。
	- 为什么使用midpoint策略？
	  如果直接将新读到的页放到队首，那么某些SQL操作（索引、扫描）会导致LRU中真正的「**热页**」被刷出，从而影响效率（LRU列表被污染）。
	- 此外，InnoDB还引入了一个参数（innodb_old_blocks_time)用于表示页读取到midpoint位置后需要等待多久才会被加入到LRU的热端。
-
  4. 页大小：默认16K，InnoDB从1.0.x开始支持压缩页（将16K的页压缩为1K、2K、4K、8K）。对于非16K的页，是通过unzip_LRU 列表进行管理的。
-
#### 重做日志缓冲
- InnoDB首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到磁盘的重做日志文件里。
-
## Checkpoint机制
- Checkpoint机制是被设计用于将缓冲区中的脏页刷回磁盘的策略，希望帮助解决：
-
  1. 缩短数据库的恢复时间；
-
  2. 防止缓冲池不够用（将脏页刷新到磁盘）；
-
  3. 重做日志不可用时，刷新脏页。因为重做日志是循环使用的，不能让其无限增大，数据库进行恢复时，并不需要已经被使用（Checkpoint过的，通过LSN「Log Sequence Number」进行标记）过的重做日志，因此这部分就可以被覆盖使用。
-
- InnoDB 中有两种 Checkpoint：
	- **Sharp Checkpoint**：发生在数据库关闭时，将所有的脏页刷回磁盘。
	- **Fuzzy Checkpoint**：在数据库运行时，根据策略将一部分而非所有脏页刷回磁盘。
-
- 几种 Fuzzy Checkpoint 的情况
	- **Master Thread Checkpoint**: 主线程按差不多每秒或每十秒的速度从缓冲池的脏页列表中（异步）刷新**一定比例**的页回磁盘。
	- **Flush LRU List Checkpoint**: InnoDB 被设计为需要保证 LRU 列表有 100 个空闲页可供使用。当新读到的页加入到LRU中而此时空闲页不满100后，会将队尾的页移除，若这些页里有脏页，则需要刷回磁盘。
	- **Async/Sync Flush Checkpoint**: 当重做日志不可用（参考上文）时，需要强制将一些脏页刷回磁盘。InnoDB 为此定义了两个百分比（75、90）：
		- 当 **未刷回磁盘的脏页大小** 介于 **重做日志大小** 的 **75**% ~ **90**% 之间时，触发脏页刷新，使得前者维持在重做日志大小的 75% 以下。如果重做日志的大小是4G，即脏页大小超过2.8G，小于3.6G时就会触发 Async Flush Checkpoint。
		- 另一种超过90%的情况，一般很少发生，只有当重做日志文件设置的太小或者脏页产生速度 远大于 刷新速度时才会产生，超过后会触发Sync Flush，从脏页列表刷新足够的脏页回磁盘，使其大小维持在75%以下。
	- **Dirty Page Too Much Checkpoint**: 当缓存池中的脏页数量太多（超过某个阈值，可设置），强制执行Checkpoint。
-
### 数据丢失与 Write Ahead Log（WAL）策略
- 用途：为了避免在进行「刷回」操作时发生宕机等情况下导致的数据丢失问题，当事务提交时，先写重做日志，再修改页。当发生宕机导致数据丢失时，通过重做日志来完成数据的恢复。（满足事务ACID中的Durability持久性要求）
-
## Master Thread做了什么
- InnoDB的主要工作都是在一个单独的Master Thread完成的：
-
### 1.0.x版本之前的Master Thread
- 具有最高的线程优先级。其内部由多个循环（loop）组成：主循环、后台循环（backgroup loop）、刷新循环（flush loop）、暂停循环（suspend loop）。Master Thread根据数据库运行的状态在这几个loop之间切换。
-
#### 主循环Loop
- 包含了大多数的操作，主要分为每秒的操作和每十秒的操作，伪代码
-
  ```C
  
  ```
-
-
-
-
-
-
-
## 一些问题
-
  1. 在DB中进行修改页，如果页不在缓冲池中，是怎样处理。从磁盘捞回吗？
-
-
-
-
## 参考资料
- 《MySQL 技术内幕 InnoDB存储引擎（第2版）》 [著] 姜承尧